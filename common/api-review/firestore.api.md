## API Report File for "@firebase/firestore"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { EmulatorMockTokenOptions } from '@firebase/util';
import { FirebaseApp } from '@firebase/app';
import { FirebaseError } from '@firebase/util';
import { LogLevelString as LogLevel } from '@firebase/logger';

// @public
export function addDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: CollectionReference<AppType, DbType>, data: WithFieldValue<AppType>): Promise<DocumentReference<AppType, DbType>>;

// @public
export type AddPrefixToKeys<Prefix extends string, T extends Record<string, unknown>> = {
    [K in keyof T & string as `${Prefix}.${K}`]+?: T[K];
};

// @public
export class AggregateField<T> {
    readonly type = "AggregateField";
}

// @public
export type AggregateFieldType = AggregateField<number | null>;

// @public
export class AggregateQuerySnapshot<AggregateSpecType extends AggregateSpec, AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    data(): AggregateSpecData<AggregateSpecType>;
    readonly query: Query<AppType, DbType>;
    readonly type = "AggregateQuerySnapshot";
}

// @public
export function aggregateQuerySnapshotEqual<AggregateSpecType extends AggregateSpec>(left: AggregateQuerySnapshot<AggregateSpecType>, right: AggregateQuerySnapshot<AggregateSpecType>): boolean;

// @public
export interface AggregateSpec {
    // (undocumented)
    [field: string]: AggregateFieldType;
}

// @public
export type AggregateSpecData<T extends AggregateSpec> = {
    [P in keyof T]: T[P] extends AggregateField<infer U> ? U : never;
};

// @public
export function and(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

// @public
export function arrayRemove(...elements: unknown[]): FieldValue;

// @public
export function arrayUnion(...elements: unknown[]): FieldValue;

// @public
export class Bytes {
    static fromBase64String(base64: string): Bytes;
    static fromUint8Array(array: Uint8Array): Bytes;
    isEqual(other: Bytes): boolean;
    toBase64(): string;
    toString(): string;
    toUint8Array(): Uint8Array;
}

// @public
export const CACHE_SIZE_UNLIMITED = -1;

// @public
export type ChildUpdateFields<K extends string, V> = V extends Record<string, unknown> ? AddPrefixToKeys<K, UpdateData<V>> : never;

// @public
export function clearIndexedDbPersistence(firestore: Firestore): Promise<void>;

// @public
export function collection(firestore: Firestore, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collection<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: CollectionReference<AppType, DbType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collection<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, path: string, ...pathSegments: string[]): CollectionReference<DocumentData, DocumentData>;

// @public
export function collectionGroup(firestore: Firestore, collectionId: string): Query<DocumentData, DocumentData>;

// @public
export class CollectionReference<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> extends Query<AppType, DbType> {
    get id(): string;
    get parent(): DocumentReference<DocumentData, DocumentData> | null;
    get path(): string;
    readonly type = "collection";
    withConverter<NewAppType = DocumentData, NewDbType extends DocumentData = NewAppType extends DocumentData ? NewAppType : DocumentData>(converter: FirestoreDataConverter<NewAppType, NewDbType>): CollectionReference<NewAppType, NewDbType>;
    withConverter(converter: null): CollectionReference<DocumentData, DocumentData>;
}

// @public
export function connectFirestoreEmulator(firestore: Firestore, host: string, port: number, options?: {
    mockUserToken?: EmulatorMockTokenOptions | string;
}): void;

// @public
export function deleteDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>): Promise<void>;

// @public
export function deleteField(): FieldValue;

// @public
export function disableNetwork(firestore: Firestore): Promise<void>;

// @public
export function doc(firestore: Firestore, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

// @public
export function doc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: CollectionReference<AppType, DbType>, path?: string, ...pathSegments: string[]): DocumentReference<AppType, DbType>;

// @public
export function doc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, path: string, ...pathSegments: string[]): DocumentReference<DocumentData, DocumentData>;

// @public
export interface DocumentChange<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    readonly doc: QueryDocumentSnapshot<AppType, DbType>;
    readonly newIndex: number;
    readonly oldIndex: number;
    readonly type: DocumentChangeType;
}

// @public
export type DocumentChangeType = 'added' | 'removed' | 'modified';

// @public
export type DocumentData = Record<string, any>;

// @public
export function documentId(): FieldPath;

// @public
export class DocumentReference<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    readonly converter: FirestoreDataConverter<AppType, DbType> | null;
    readonly firestore: Firestore;
    get id(): string;
    get parent(): CollectionReference<AppType, DbType>;
    get path(): string;
    readonly type = "document";
    withConverter<NewAppType = DocumentData, NewDbType extends DocumentData = NewAppType extends DocumentData ? NewAppType : DocumentData>(converter: FirestoreDataConverter<NewAppType, NewDbType>): DocumentReference<NewAppType, NewDbType>;
    withConverter(converter: null): DocumentReference<DocumentData, DocumentData>;
}

// @public
export class DocumentSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    protected constructor();
    data(options?: SnapshotOptions): AppType | undefined;
    exists(): this is QueryDocumentSnapshot<AppType, DbType>;
    get(fieldPath: string | FieldPath, options?: SnapshotOptions): any;
    get id(): string;
    readonly metadata: SnapshotMetadata;
    get ref(): DocumentReference<AppType, DbType>;
}

export { EmulatorMockTokenOptions }

// @public @deprecated
export function enableIndexedDbPersistence(firestore: Firestore, persistenceSettings?: PersistenceSettings): Promise<void>;

// @public @deprecated
export function enableMultiTabIndexedDbPersistence(firestore: Firestore): Promise<void>;

// @public
export function enableNetwork(firestore: Firestore): Promise<void>;

// @public
export function endAt(snapshot: DocumentSnapshot<unknown>): QueryEndAtConstraint;

// @public
export function endAt(...fieldValues: unknown[]): QueryEndAtConstraint;

// @public
export function endBefore(snapshot: DocumentSnapshot<unknown>): QueryEndAtConstraint;

// @public
export function endBefore(...fieldValues: unknown[]): QueryEndAtConstraint;

// @public
export class FieldPath {
    constructor(...fieldNames: string[]);
    isEqual(other: FieldPath): boolean;
}

// @public
export abstract class FieldValue {
    abstract isEqual(other: FieldValue): boolean;
}

// @public
export class Firestore {
    get app(): FirebaseApp;
    toJSON(): object;
    type: 'firestore-lite' | 'firestore';
}

// @public
export interface FirestoreDataConverter<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    fromFirestore(snapshot: QueryDocumentSnapshot<DbType, DbType>, options?: SnapshotOptions): AppType;
    toFirestore(modelObject: WithFieldValue<AppType>): WithFieldValue<DbType>;
    toFirestore(modelObject: PartialWithFieldValue<AppType>, options: SetOptions): PartialWithFieldValue<DbType>;
}

// @public
export class FirestoreError extends FirebaseError {
    readonly code: FirestoreErrorCode;
    readonly message: string;
    readonly stack?: string;
}

// @public
export type FirestoreErrorCode = 'cancelled' | 'unknown' | 'invalid-argument' | 'deadline-exceeded' | 'not-found' | 'already-exists' | 'permission-denied' | 'resource-exhausted' | 'failed-precondition' | 'aborted' | 'out-of-range' | 'unimplemented' | 'internal' | 'unavailable' | 'data-loss' | 'unauthenticated';

// @public
export type FirestoreLocalCache = MemoryLocalCache | PersistentLocalCache;

// @public
export interface FirestoreSettings {
    cacheSizeBytes?: number;
    experimentalAutoDetectLongPolling?: boolean;
    experimentalForceLongPolling?: boolean;
    host?: string;
    ignoreUndefinedProperties?: boolean;
    localCache?: FirestoreLocalCache;
    ssl?: boolean;
}

// @public
export class GeoPoint {
    constructor(latitude: number, longitude: number);
    isEqual(other: GeoPoint): boolean;
    get latitude(): number;
    get longitude(): number;
    toJSON(): {
        latitude: number;
        longitude: number;
    };
}

// @public
export function getCountFromServer<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>): Promise<AggregateQuerySnapshot<{
    count: AggregateField<number>;
}, AppType, DbType>>;

// @public
export function getDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>): Promise<DocumentSnapshot<AppType, DbType>>;

// @public
export function getDocFromCache<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>): Promise<DocumentSnapshot<AppType, DbType>>;

// @public
export function getDocFromServer<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>): Promise<DocumentSnapshot<AppType, DbType>>;

// @public
export function getDocs<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>): Promise<QuerySnapshot<AppType, DbType>>;

// @public
export function getDocsFromCache<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>): Promise<QuerySnapshot<AppType, DbType>>;

// @public
export function getDocsFromServer<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>): Promise<QuerySnapshot<AppType, DbType>>;

// @public
export function getFirestore(app: FirebaseApp): Firestore;

// @public
export function getFirestore(): Firestore;

// @public
export function increment(n: number): FieldValue;

// @beta
export interface Index {
    // (undocumented)
    [key: string]: unknown;
    readonly collectionGroup: string;
    readonly fields?: IndexField[];
}

// @beta
export interface IndexConfiguration {
    // (undocumented)
    [key: string]: unknown;
    readonly indexes?: Index[];
}

// @beta
export interface IndexField {
    // (undocumented)
    [key: string]: unknown;
    readonly arrayConfig?: 'CONTAINS';
    readonly fieldPath: string;
    readonly order?: 'ASCENDING' | 'DESCENDING';
}

// @public
export function initializeFirestore(app: FirebaseApp, settings: FirestoreSettings, databaseId?: string): Firestore;

// @public
export function limit(limit: number): QueryLimitConstraint;

// @public
export function limitToLast(limit: number): QueryLimitConstraint;

// @public
export function loadBundle(firestore: Firestore, bundleData: ReadableStream<Uint8Array> | ArrayBuffer | string): LoadBundleTask;

// @public
export class LoadBundleTask implements PromiseLike<LoadBundleTaskProgress> {
    catch<R>(onRejected: (a: Error) => R | PromiseLike<R>): Promise<R | LoadBundleTaskProgress>;
    onProgress(next?: (progress: LoadBundleTaskProgress) => unknown, error?: (err: Error) => unknown, complete?: () => void): void;
    then<T, R>(onFulfilled?: (a: LoadBundleTaskProgress) => T | PromiseLike<T>, onRejected?: (a: Error) => R | PromiseLike<R>): Promise<T | R>;
}

// @public
export interface LoadBundleTaskProgress {
    bytesLoaded: number;
    documentsLoaded: number;
    taskState: TaskState;
    totalBytes: number;
    totalDocuments: number;
}

export { LogLevel }

// @public
export interface MemoryCacheSettings {
    garbageCollector?: MemoryGarbageCollector;
}

// @public
export interface MemoryEagerGarbageCollector {
    // (undocumented)
    kind: 'memoryEager';
}

// @public
export function memoryEagerGarbageCollector(): MemoryEagerGarbageCollector;

// @public
export type MemoryGarbageCollector = MemoryEagerGarbageCollector | MemoryLruGarbageCollector;

// @public
export interface MemoryLocalCache {
    // (undocumented)
    kind: 'memory';
}

// @public
export function memoryLocalCache(settings?: MemoryCacheSettings): MemoryLocalCache;

// @public
export interface MemoryLruGarbageCollector {
    // (undocumented)
    kind: 'memoryLru';
}

// @public
export function memoryLruGarbageCollector(settings?: {
    cacheSizeBytes?: number;
}): MemoryLruGarbageCollector;

// @public
export function namedQuery(firestore: Firestore, name: string): Promise<Query | null>;

// @public
export type NestedUpdateFields<T extends Record<string, unknown>> = UnionToIntersection<{
    [K in keyof T & string]: ChildUpdateFields<K, T[K]>;
}[keyof T & string]>;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, observer: {
    next?: (snapshot: DocumentSnapshot<AppType, DbType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: DocumentSnapshot<AppType, DbType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, onNext: (snapshot: DocumentSnapshot<AppType, DbType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, options: SnapshotListenOptions, onNext: (snapshot: DocumentSnapshot<AppType, DbType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, observer: {
    next?: (snapshot: QuerySnapshot<AppType, DbType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, options: SnapshotListenOptions, observer: {
    next?: (snapshot: QuerySnapshot<AppType, DbType>) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, onNext: (snapshot: QuerySnapshot<AppType, DbType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, options: SnapshotListenOptions, onNext: (snapshot: QuerySnapshot<AppType, DbType>) => void, onError?: (error: FirestoreError) => void, onCompletion?: () => void): Unsubscribe;

// @public
export function onSnapshotsInSync(firestore: Firestore, observer: {
    next?: (value: void) => void;
    error?: (error: FirestoreError) => void;
    complete?: () => void;
}): Unsubscribe;

// @public
export function onSnapshotsInSync(firestore: Firestore, onSync: () => void): Unsubscribe;

// @public
export function or(...queryConstraints: QueryFilterConstraint[]): QueryCompositeFilterConstraint;

// @public
export function orderBy(fieldPath: string | FieldPath, directionStr?: OrderByDirection): QueryOrderByConstraint;

// @public
export type OrderByDirection = 'desc' | 'asc';

// @public
export type PartialWithFieldValue<T> = Partial<T> | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: PartialWithFieldValue<T[K]> | FieldValue;
} : never);

// @public
export interface PersistenceSettings {
    forceOwnership?: boolean;
}

// @public
export interface PersistentCacheSettings {
    cacheSizeBytes?: number;
    tabManager?: PersistentTabManager;
}

// @public
export interface PersistentLocalCache {
    // (undocumented)
    kind: 'persistent';
}

// @public
export function persistentLocalCache(settings?: PersistentCacheSettings): PersistentLocalCache;

// @public
export interface PersistentMultipleTabManager {
    // (undocumented)
    kind: 'PersistentMultipleTab';
}

// @public
export function persistentMultipleTabManager(): PersistentMultipleTabManager;

// @public
export interface PersistentSingleTabManager {
    // (undocumented)
    kind: 'persistentSingleTab';
}

// @public
export function persistentSingleTabManager(settings: PersistentSingleTabManagerSettings | undefined): PersistentSingleTabManager;

// @public
export interface PersistentSingleTabManagerSettings {
    forceOwnership?: boolean;
}

// @public
export type PersistentTabManager = PersistentSingleTabManager | PersistentMultipleTabManager;

// @public
export type Primitive = string | number | boolean | undefined | null;

// @public
export class Query<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    protected constructor();
    readonly converter: FirestoreDataConverter<AppType, DbType> | null;
    readonly firestore: Firestore;
    readonly type: 'query' | 'collection';
    withConverter(converter: null): Query<DocumentData, DocumentData>;
    withConverter<NewAppType = DocumentData, NewDbType extends DocumentData = NewAppType extends DocumentData ? NewAppType : DocumentData>(converter: FirestoreDataConverter<NewAppType, NewDbType>): Query<NewAppType, NewDbType>;
}

// @public
export function query<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, compositeFilter: QueryCompositeFilterConstraint, ...queryConstraints: QueryNonFilterConstraint[]): Query<AppType, DbType>;

// @public
export function query<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(query: Query<AppType, DbType>, ...queryConstraints: QueryConstraint[]): Query<AppType, DbType>;

// @public
export class QueryCompositeFilterConstraint {
    readonly type: 'or' | 'and';
}

// @public
export abstract class QueryConstraint {
    abstract readonly type: QueryConstraintType;
}

// @public
export type QueryConstraintType = 'where' | 'orderBy' | 'limit' | 'limitToLast' | 'startAt' | 'startAfter' | 'endAt' | 'endBefore';

// @public
export class QueryDocumentSnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> extends DocumentSnapshot<AppType, DbType> {
    // @override
    data(options?: SnapshotOptions): AppType;
}

// @public
export class QueryEndAtConstraint extends QueryConstraint {
    readonly type: 'endBefore' | 'endAt';
}

// @public
export function queryEqual<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(left: Query<AppType, DbType>, right: Query<AppType, DbType>): boolean;

// @public
export class QueryFieldFilterConstraint extends QueryConstraint {
    readonly type = "where";
}

// @public
export type QueryFilterConstraint = QueryFieldFilterConstraint | QueryCompositeFilterConstraint;

// @public
export class QueryLimitConstraint extends QueryConstraint {
    readonly type: 'limit' | 'limitToLast';
}

// @public
export type QueryNonFilterConstraint = QueryOrderByConstraint | QueryLimitConstraint | QueryStartAtConstraint | QueryEndAtConstraint;

// @public
export class QueryOrderByConstraint extends QueryConstraint {
    readonly type = "orderBy";
}

// @public
export class QuerySnapshot<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData> {
    docChanges(options?: SnapshotListenOptions): Array<DocumentChange<AppType, DbType>>;
    get docs(): Array<QueryDocumentSnapshot<AppType, DbType>>;
    get empty(): boolean;
    forEach(callback: (result: QueryDocumentSnapshot<AppType, DbType>) => void, thisArg?: unknown): void;
    readonly metadata: SnapshotMetadata;
    readonly query: Query<AppType, DbType>;
    get size(): number;
}

// @public
export class QueryStartAtConstraint extends QueryConstraint {
    readonly type: 'startAt' | 'startAfter';
}

// @public
export function refEqual<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(left: DocumentReference<AppType, DbType> | CollectionReference<AppType, DbType>, right: DocumentReference<AppType, DbType> | CollectionReference<AppType, DbType>): boolean;

// @public
export function runTransaction<T>(firestore: Firestore, updateFunction: (transaction: Transaction) => Promise<T>, options?: TransactionOptions): Promise<T>;

// @public
export function serverTimestamp(): FieldValue;

// @public
export function setDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, data: WithFieldValue<AppType>): Promise<void>;

// @public
export function setDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, data: PartialWithFieldValue<AppType>, options: SetOptions): Promise<void>;

// @beta
export function setIndexConfiguration(firestore: Firestore, configuration: IndexConfiguration): Promise<void>;

// @beta
export function setIndexConfiguration(firestore: Firestore, json: string): Promise<void>;

// @public
export function setLogLevel(logLevel: LogLevel): void;

// @public
export type SetOptions = {
    readonly merge?: boolean;
} | {
    readonly mergeFields?: Array<string | FieldPath>;
};

// @public
export function snapshotEqual<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(left: DocumentSnapshot<AppType, DbType> | QuerySnapshot<AppType, DbType>, right: DocumentSnapshot<AppType, DbType> | QuerySnapshot<AppType, DbType>): boolean;

// @public
export interface SnapshotListenOptions {
    readonly includeMetadataChanges?: boolean;
}

// @public
export class SnapshotMetadata {
    readonly fromCache: boolean;
    readonly hasPendingWrites: boolean;
    isEqual(other: SnapshotMetadata): boolean;
}

// @public
export interface SnapshotOptions {
    readonly serverTimestamps?: 'estimate' | 'previous' | 'none';
}

// @public
export function startAfter(snapshot: DocumentSnapshot<unknown>): QueryStartAtConstraint;

// @public
export function startAfter(...fieldValues: unknown[]): QueryStartAtConstraint;

// @public
export function startAt(snapshot: DocumentSnapshot<unknown>): QueryStartAtConstraint;

// @public
export function startAt(...fieldValues: unknown[]): QueryStartAtConstraint;

// @public
export type TaskState = 'Error' | 'Running' | 'Success';

// @public
export function terminate(firestore: Firestore): Promise<void>;

// @public
export class Timestamp {
    constructor(
    seconds: number,
    nanoseconds: number);
    static fromDate(date: Date): Timestamp;
    static fromMillis(milliseconds: number): Timestamp;
    isEqual(other: Timestamp): boolean;
    readonly nanoseconds: number;
    static now(): Timestamp;
    readonly seconds: number;
    toDate(): Date;
    toJSON(): {
        seconds: number;
        nanoseconds: number;
    };
    toMillis(): number;
    toString(): string;
    valueOf(): string;
}

// @public
export class Transaction {
    delete<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>): this;
    get<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>): Promise<DocumentSnapshot<AppType, DbType>>;
    set<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: WithFieldValue<AppType>): this;
    set<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: PartialWithFieldValue<AppType>, options: SetOptions): this;
    update<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: UpdateData<DbType>): this;
    update<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): this;
}

// @public
export interface TransactionOptions {
    readonly maxAttempts?: number;
}

// @public
export type UnionToIntersection<U> = (U extends unknown ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

// @public
export interface Unsubscribe {
    (): void;
}

// @public
export type UpdateData<T> = T extends Primitive ? T : T extends {} ? {
    [K in keyof T]?: UpdateData<T[K]> | FieldValue;
} & NestedUpdateFields<T> : Partial<T>;

// @public
export function updateDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, data: UpdateData<DbType>): Promise<void>;

// @public
export function updateDoc<AppType = DocumentData, DbType extends DocumentData = AppType extends DocumentData ? AppType : DocumentData>(reference: DocumentReference<AppType, DbType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): Promise<void>;

// @public
export function waitForPendingWrites(firestore: Firestore): Promise<void>;

// @public
export function where(fieldPath: string | FieldPath, opStr: WhereFilterOp, value: unknown): QueryFieldFilterConstraint;

// @public
export type WhereFilterOp = '<' | '<=' | '==' | '!=' | '>=' | '>' | 'array-contains' | 'in' | 'array-contains-any' | 'not-in';

// @public
export type WithFieldValue<T> = T | (T extends Primitive ? T : T extends {} ? {
    [K in keyof T]: WithFieldValue<T[K]> | FieldValue;
} : never);

// @public
export class WriteBatch {
    commit(): Promise<void>;
    delete<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>): WriteBatch;
    set<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: WithFieldValue<AppType>): WriteBatch;
    set<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: PartialWithFieldValue<AppType>, options: SetOptions): WriteBatch;
    update<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, data: UpdateData<DbType>): WriteBatch;
    update<AppType, DbType extends DocumentData>(documentRef: DocumentReference<AppType, DbType>, field: string | FieldPath, value: unknown, ...moreFieldsAndValues: unknown[]): WriteBatch;
}

// @public
export function writeBatch(firestore: Firestore): WriteBatch;


```
